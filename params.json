{"name":"Ometa-js","body":"Introduction To OMeta/JS\r\n========================\r\nWriting parsers by hand can be quite tedious and error-prone, especially when implementing a language specification that still evolves or when experimenting with novel language features. Small changes in a grammar may result in complex changes of the parser. Thus, parser-generators are often used to automate this process. As we have seen in chapter [chap:compilation-process], a compiler commonly consists not only of a parser but also of a lexer, several translators and finally a code-generator - all of which being created with different tools or frameworks and maybe even using different languages. Alessandro Warth created OMeta to unify all of those tools in order to flatten the learning curve and to make experimenting with languages more easy [OMeta].\r\n\r\nThe goal of this chapter is to provide a solid understanding of how to work with OMeta and specially OMeta/JS. Of course Warth's thesis [OMeta] is a great source for background information and this chapter may be seen as a restructured, updated and enriched form of [OMeta, chapter 2].\r\n\r\nOMeta is a general purpose **pattern matching language** based on parsing expression grammars (abbr. PEG). As we have seen PEGs unite the flexibility of CFGs and REs and thereby remove the separation between the process of lexical analysis and parsing. They usually operate on characters as terminals and hence can only be used to match strings.\r\n\r\nOMeta circumvents this limitation by allowing every object of the host-language to be a terminal, thus making it possible to use OMeta in almost every step of the compilation process. It also offers many extensions to PEG like **parametrized rules**, **higher order rules** and **grammar inheritance** described in the remainder of this chapter.\r\n\r\nWorking with OMeta can be split into three single steps:\r\n\r\n1. Write your grammar in OMeta-language\r\n2. Set up the OMeta-compiler and compile the grammar\r\n3. Use the resulting grammar-object to match and translate input-streams\r\n\r\nOMeta uses **memoization** to increase performance and therefore reduces the drawbacks resulting from backtracking (Also see [FordPackrat] and chapter [sub:memoization]). In addition, it allows the use of **left-recursive rules** by modifying the memoization algorithm (See [WarthLeftRecursion] and [OMeta, chapter 3]).\r\n\r\n\r\nOMeta/JS\r\n--------\r\nBeing a generic language for grammar-description, OMeta has been implemented in many different **host languages**. In the remainder we will take a look atdescribe Alessandro Warth's reference implementation written in JavaScript (called OMeta/JS).\r\n\r\nIn order to get an idea of how an OMeta grammar looks like, the following listing shows a grammar with three simple rules, each separated by a comma. This simplified grammar matches JavaScript identifiers like `foobar`, `$1` and `_global`, always starting with rule `identifier`.\r\n\r\n    ometa ID {\r\n      identifier = nameFirst namePart*,\r\n      nameFirst  = letter | '$' | '_',   \r\n      namePart   = nameFirst | digit  \r\n    }\r\n\r\nHere the structure of every OMeta gets visible. Since OMeta/JS is a combination of the OMeta-language and JavaScript the keyword `ometa` is used to announce that a following section is written in OMeta. After the introductory keyword the **name** of the OMeta grammar is expected before it's implementation can take place inside of the following block. Compiling this grammar to JavaScript results in a JavaScript-object `ID` containing three methods to match the specified rules. Since no parent-grammar has been specified OMeta assumes that it's base grammar `OMeta` should be the parent. Hence, a prototypal link to an object representing this base grammar is added as depicted in the figure below. Here we can get a quick idea of how OMeta/JS models the inheritance of different grammars by using the prototype-chain.\r\n\r\n<figure>\r\n  <img src=\"images/object-relationship.png\" alt=\"Grammar Object ID inherits from base grammar OMeta by the means of prototypal inheritance\" />\r\n  <figcaption>The two grammar objects ID and OMeta</figcaption>\r\n</figure>\r\n  \r\n  \r\nWriting Grammars\r\n----------------\r\nThe most important part of implementing a parser by the means of a parser generator is to write a grammar. To accomplish this task we will start off by taking a look at the different tools and syntax elements provided by OMeta.\r\n\r\n### Differences to PEG #\r\nOMeta supports almost all default operators that can be found in PEG. Nevertheless, new features have been introduced which conflict syntactically with existing operators. The following table illustrates the differences to the syntax as it is known from PEG.\r\n\r\n<figure>\r\n  <div class=\"def-table\">\r\n  \r\n  <dl>\r\n  <dt><code>expr_a | expr_b</code>\r\n  <dd>Priotized <strong>Choice</strong> (try <code>expr_a</code> then <code>expr_b</code>)\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>expr_a ‚ê£ expr_b</code>\r\n  <dd><strong>Sequence</strong> (<code>expr_a</code> followed by <code>expr_b</code>)\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>(expr)</code>\r\n  <dd><strong>Grouping</strong> to force precedence\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>expr?</code>\r\n  <dd><strong>Optional</strong> occurance of <code>expr</code>\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>expr+</code>\r\n  <dd><strong>Multiple</strong> occurance of <code>expr</code>, but at least once\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>expr*</code>\r\n  <dd><strong>Zero or many</strong> subsequent <code>expr</code>.\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>&expr</code>\r\n  <dd><strong>Positive lookahead</strong> of <code>expr</code>. Does not consume anything.\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>~expr</code>\r\n  <dd><strong>Negative lookahead</strong> of <code>expr</code>. Does not consume anything.\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>anything</code>\r\n  <dd><strong>Consumation</strong> of the next input without inspecting it\r\n  </dl>\r\n  \r\n  </div>\r\n  <figcaption>PEG Operators in OMeta</figcaption>\r\n</figure>\r\n\r\nCharacter classes as they are known from regular expressions and adopted by PEG do not have an equivalent syntax in OMeta. In order to allow the pattern matching of lists (as it can be seen in section [sub:Pattern-Matching]), brackets had to be reserved and thus could not be used to match character classes. Regardless of the missing syntax it is still possible in OMeta/JS to implement a character range by using parametrized rules. For example the class `[a-z]` can be matched by the rule `range('a', 'z')`. The implementation of range can be found in appendix [chap:OMeta-methods].\r\n\r\nThe use of basic PEG operators within OMeta is demonstrated in the next code sample.\r\n\r\n    ometa Numbers {\r\n      number     = decimal,\r\n      decimal    = '-'? decimalInt+ ('.' digit+)? expPart?\r\n                 | '-'? ('.' digit+) expPart?,\r\n      decimalInt = '0' | (~'0' digit) digit*,   \r\n      expPart    = ('e' | 'E') ('+' | '-')? digit+  \r\n    }\r\n\r\nAs already known from PEG, the lookahead operators assure whether the next input-token does (`&` positive) or does not (`~` negative) match the given expression. It is important to note that thereby **no input is consumed**. In this example it gets visible how the negative lookahead operator is used to exclude the character `'0'` which would otherwise be matched by the rule `digit`. The starting point for this grammar is the rule `number`. The grammar matches all allowed decimal numbers like `-3`, `4.7`, `.6` and `6.18e-1`.\r\n\r\n### Pattern Matching #\r\nIn contrast to PEG which only allows to match a stream of characters, OMeta is able to match a stream of arbitrary host-language objects. There are quite a few types of objects in JavaScript for which OMeta provides a dedicated syntax as it can be seen in the following table.\r\n\r\n<figure>\r\n  <div class=\"def-table\">\r\n  <dl>\r\n  <dt><code>'c'</code>\r\n  <dd>Matches a string-object of the host-language. During parsing a string is decomposed into a stream of characters. Hence, most of the time this notation is used to match single characters\r\n  </dl>\r\n\r\n  <dl>\r\n  <dt><code>&#96;&#96;string''</code>\r\n  <dd>Matches a sequence of characters (Please note, that the string is delimited by two backticks on the left and two single quotes on the right hand side)\r\n  </dl>\r\n\r\n  <dl>\r\n  <dt><code>1337</code>\r\n  <dd>Matches a number-object of the host-language\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>[char 'o' 'o' 1234]</code>\r\n  <dd>The list notation allows matching a sequence of arbitrary objects inside of a list.\r\n  </dl>\r\n  \r\n  </div>\r\n  <figcaption>Syntax for matching different types of objects</figcaption>\r\n</figure>\r\n\r\nLike with PEG, the most basic terminals a parser may recognize are single characters and sequences of characters. When matching a string like `\"var foo = 4\"` OMeta destructs this string into it's single characters in order to form a stream:\r\n\r\n    ['v', 'a', 'r', ' ', 'f', 'o', 'o', ' ', '=', ' ', '4']\r\n\r\nHere it gets visible why every single character has to be matched separately. If a sequence of characters like `var` is expected this has to be denoted explicitly by using the character sequence notation <code>&#96;&#96;var''</code>. In fact, this notation is semantically equivalent to `'v'` `'a'` `'r'`.\r\n\r\nIn contrast to parsers, a translator has to work on structures. For this task OMeta provides a notation that can be used to match lists. Consider the task of converting a prefix notation, as it is used by Lisp, to be infix. Given the following input\r\n\r\n    ['+', 5, ['-', 3, 8]]\r\n\r\na grammar has to recursively match the contents of the lists. Like already said, this can be performed by using the list-notation like\r\n\r\n    ometa PreToInfix {\r\n      list     = [operator:op content:first content:second] -> [first, op, second],\r\n      content  = list | number,\r\n      operator = '+' | '-' | '*' | '/'\r\n    }\r\n\r\nPlease note that in contrast to JavaScript arrays, the elements inside of the list-notation are separated by **whitespaces** and **not commas**. To transform the output of rule `list`, semantic actions are used which will be presented in subsequent sections.\r\n\r\nGenerally speaking, every JavaScript object may be matched by utilizing predicates. For example the rule\r\n\r\n    expressions = anything:n ?(n.name == expr)\r\n\r\ncan be used to match objects like `{ name: \"expr\", contents: [] }`. Until now, there is no special pattern matching syntax for generic objects.\r\n\r\n\r\n### Semantic Predicates #\r\nSince OMeta/JS is an aggregation of OMeta and JavaScript, we can use JavaScript inside of `semantic predicates` to refine the matching process. The host-language expression inside of a semantic predicate should evaluate to a boolean value. If the resulting value is `falsy`, the matching of the current rule is assumed to be failed and therefore aborted, whereas a truthy value leads to a continuation of the matching-process. The following grammar uses predicates to differ between even and odd digits in order to match numbers like `381496`. It gets visible that the prefix-operator `?` is followed by a JavaScript expression which may, but don't necessarily has to be wrapped in parenthesis.\r\n\r\n    function even(digit) {\r\n      return parseInt(digit) % 2 === 0;\r\n    }\r\n    ometa EvenOdd {\r\n      even   = digit:d ?even(d),\r\n      odd    = digit:d ?( !even(d) ),\r\n      number = <(even odd)+ even?\r\n               | even\r\n               >:n -> parseInt(n)\r\n    }\r\n\r\nOf course the function even could have also been inlined in the semantic predicates like:\r\n\r\n    even = digit:d ?(parseInt(d) % 2 === 0)\r\n\r\nIn OMeta, the result of the last expression within a rule always is used as result of the rule. Since the semantic predicate returns a boolean value, the result of the rules `even` and `odd` is this boolean value and not the digit itself. To bypass this problem the capture operator `<...>` is used that records all input which is matched by the enclosed rules. Another solution to this problem would have been to add a semantic action at the end of each rule:\r\n\r\n    even = digit:d ?even(d)      -> d,\r\n    odd  = digit:d ?( !even(d) ) -> d,\r\n\r\nSemantic predicates also can be used to include context information in matching decisions. For example it might be checked whether a variable, to which a value is about to be bound, has been declared before hand.\r\n\r\n\r\n### Semantic Actions #\r\nUsually, it is the job of a grammar to decide whether or not an input can be matched using the given rules. Although this is a useful information, we often need to work with the recognized input in order to extract information or to modify it. For example a stream of strings may be transformed into an intermediate representation like an abstract syntax tree. The other way around, an existing AST can be used as input to a translator to be converted to code again. For this purpose the output of each rule may be transformed using so called **semantic actions**.\r\n\r\nThere are three different ways to express semantic actions in OMeta. The first one, which is mostly used to transform the output of a rule, is denoted by the arrow-operator `->`. It may appear after each expression and is delimited by either a comma (end of rule), pipe-character (end of choice) or closing curly brace (end of grammar). Hence, it's precedence is higher than a choice, but lower than a sequence. If a programmer wants to define a semantic action to manipulate the output of a choice-expression as a whole and not for a individual option, the choice has to be wrapped in parenthesis. The implementation of a semantic action can be any **expression** of the host language.\r\n\r\nAgain, if no semantic action is given for a rule, the result of the last applied expression is used without any transformation.\r\n\r\n    ometa Numbers {\r\n      number     = decimal,\r\n      decimal    = <'-'? decimalInt+ ('.' digit+)? expPart?>:n -> parseFloat(n)\r\n                 | <'-'? ('.' digit+) expPart?>:n              -> parseFloat(n),\r\n      decimalInt = '0' | (~'0' digit) digit*,   \r\n      expPart    = ('e' | 'E') ('+' | '-')? digit+\r\n    }\r\n\r\nThe above grammar is a enhancement of the grammar previously seen. Semantic actions are used in rule decimal on the right-hand side of every choice to call the JavaScript function `parseFloat(n)`. But where does the identifier `n` come from and to which value is it bound? The **capture operator**, denoted by `< ... >` captures the input used to match the inner expressions. It is very useful if we want to work with the consumed input independently of any transformations performed in the descendant rules. Using the property assignment operator `lhsExpr:id` the result of evaluating the left-hand side expression is bound to the identifier, which can be accessed in every associated host-language code like semantic actions, predicates and calls to parametrized rules.\r\n\r\nWhen trying to find out in which scope an identifier can be used, we have to recall that every rule is compiled to it's own JavaScript function. Thus, every variable defined by the assignment operator can be accessed only within the corresponding rule. \r\n\r\n<figure>\r\n  <div class=\"def-table\">\r\n  <dl>\r\n  <dt><code>expr -> <span class=\"host\">host_expr</span></code>\r\n  <dd><strong>Semantic action</strong> which transforms the result of <code>expr</code>, using an expression in the host language. (i.e. JavaScript)\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>{<span class=\"host\">host_expr</span>}</code>\r\n  <dd><strong>Semantic action</strong>, equivalent to the above except that the host expression is enclosed by curly braces.\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>!<span class=\"host\">host_expr</span></code>\r\n  <dd><strong>Semantic action</strong>, again equivalent to arrow notation\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>?<span class=\"host\">host_expr</span></code>\r\n  <dd><strong>Semantic predicate</strong> - if <code><span class=\"host\">host_expr</span></code> evaluates to <code>true</code>, than the rule matches sucessfully.\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>rule( <span class=\"host\">host_expr</span> )</code>\r\n  <dd><strong>Parametrized rule</strong> - the result of <code><span class=\"host\">host_expr</span></code> is prepended to the inputstream before <code>rule</code> is applied.\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>expr:<span class=\"host\">id</span></code>\r\n  <dd><strong>Assignment operator</strong> - binds the result of <code>expr</code> to the variable <code><span class=\"host\">id</span></code> which can be used in host-language context\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>&lt; expr &gt;</code>\r\n  <dd><strong>Capture operator</strong> - works like the grouping-operator, but captures all consumed input used to match <code>expr</code> and returns it.\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>@&lt;rule&gt;</code>\r\n  <dd><strong>Index capture operator</strong> - returns an object that contains the indices framing the consumed input (e.g. { fromIdx: 3, toIdx: 7 })\r\n  </dl>\r\n  \r\n  <dl>\r\n  <dt><code>Foreign.rule</code>\r\n  <dd><strong>Foreign rule invokation</strong> - calls rule <code>rule</code>, residing in the foreign grammar <code>Foreign</code>\r\n  </dl>\r\n  \r\n  </div>\r\n  <figcaption>Summary of OMeta syntax, as additional to PEG operators</figcaption>\r\n</figure>\r\n\r\nThe above table gives an overview over the different syntactical extensions OMeta offers. The first three entries of the table all represent semantic actions. They only differ in their syntax. Semantic actions are executed during the matching process according to their position within a rule. The side-effects created by semantic actions are not automatically undone by OMeta if a rule does not match in the end. The behavior of creating side-effects is visually emphasized by the exclamation prefix notation.\r\n\r\n\r\n### Parametrized Rules #\r\nOMeta adds even more flexibility to the grammar by allowing the use of arguments on rules, so called **parametrized rules**. Those rules behave basically the same as the one without arguments. The passed arguments are simply prepended to the input stream, before the rule is matched. Consequently, parametrized rules also support pattern matching on their parameters. Thus, the notation `rule :a :b` is only shorthand for `rule anything:a anything:b`.\r\n\r\nLet's examine an extension to the above grammar EvenOdd. Instead of defining multiple rules, one for each digit-type, there is only one parametrized rule.\r\n\r\n    ometa EvenOdd {\r\n      even   :yes = digit:d ?(yes === even(digit)),\r\n      number      = <(even(true) even(false))+ even(true)?\r\n                    | even(true)\r\n                    >:n -> parseInt(n)\r\n    }\r\n\r\nIt is important to point out that the call-arguments of parametrized rules can be any valid expressions of the host language. The result of the expression is than bound to the parameter of the invoked parametrized rule. In the first call to `even` the JavaScript value `true` is bound to the parameter `yes` and therefore further can be used in all locations where host-language is allowed.\r\n\r\nAnother example for parametrized rules is the built-in function `token(tok)`. As previously stated, OMeta can be used as \"one shoe fit's it all\" solution for the diverse compilation stages. The `token` rule helps to combine \"scannerful\" and \"scannerless\" parsing. The stage of lexical analysis, usually performed by a **lexer**, can be included in the parser-grammar:\r\n\r\n    ometa Lisp {\r\n      // Lexer\r\n      identifier = <letter+>:id      -> { type: \"Id\", value: id },\r\n      number     = <digit+>:num      -> { type: \"Number\", value: parseInt(num) },  \r\n      punctuator = '(' | ')' |'.' | ',',\r\n\r\n      token :tt  = spaces ( punctuator:t             ?(t == tt)      -> t\r\n                          | (identifier | number):t  ?(t.type == tt) -> t\r\n                          ),\r\n\r\n      // Parser\r\n      list       = token(\"(\") (atom | list)+:cs token(\")\") -> { type: \"List\", content: cs },\r\n      atom       = token(\"Id\") | token(\"Number\")  \r\n    }\r\n\r\nStarting with rule list the grammar can be used to parse simple Lisp-like lists. The given input `\"(plus 4 (minus 8 6)\"` results in the tree consisting of objects:\r\n\r\n    { type: \"List\", content: [\r\n      { type: \"Id\", value: \"plus\" },\r\n      { type: \"Number\", value: 4 },\r\n      { type: \"List\", content: [\r\n        { type: \"Id\", value: \"minus\" },\r\n        { type: \"Number\", value: 8 },\r\n        { type: \"Number\", value: 6 }]\r\n      }]\r\n    }\r\n\r\nEvery object has one property `type` to specify it's kind. Additionally identifier and numbers save their values in the property `value`. Lists in turn store the contained list items in the property `content`.\r\n\r\nAs it gets clearly visible the lexer is included directly in the parser grammar. Every time a token needs to be scanned the method `token` is invoked, providing the required type of token as a string. OMeta provides a special syntax for this kind of invocation since it is used pretty often. Instead of writing `token(\"Id\")` the programmer might simply use a shorthand syntax `\"Id\"`. At first glance this might easily be mixed up with the matching of strings. Hence, it is important to keep in mind that strings are broken down to character sequences and therefore the syntax <code>&#96;&#96;string''</code> or `seq(\"string\")` has to be used.\r\n\r\nUsing the shorthand notation for token the parser rules may be rewritten as\r\n\r\n    list       = \"(\" (atom | list)+:cs \")\" -> { type: \"List\", content: cs },\r\n    atom       = \"Id\" | \"Number\"\r\n\r\nwhich is much more convenient to read and write.\r\n\r\n\r\n### Higher-Order Rules #\r\nAmong the methods of the OMeta base grammar the `rule apply(rule_name)` can be found, which expects `rule_name` to be a string and invokes the rule in place. Therefore, a call to `apply(\"myrule\")` is identical to `myrule`. Equipped with `apply` and parametrized rules it is possible to create **higher order rules** by passing rule-names as arguments. The higher order rule itself can in turn make use of `apply`. In OMeta some built-in functions are implemented that way. In appendix [chap:OMeta-methods] a pseudo implementation of the base grammar with all of it's built-in rules can be found. For example let's analyze `listOf(rule, sep)` that can be used to match a list of items. The internal implementation is close to:\r\n\r\n    listOf :rule :sep = apply(rule):f (token(sep) apply(rule)):r*  -> [f].concat(r)\r\n                      | empty                                      -> []\r\n\r\nEach item has to match rule and is delimited by the provided separator. Here we can see how the given rule is applied at all positions where a matching item is expected. Considering the above number-grammar, a call to `listOf(#decimal, ',')` could match an input string like `\"1.5, 4, -8\"`. The usage of the dubious literal `#decimal` as first argument will be explained in the following section.\r\n\r\n### It's all about Context: OMeta or JavaScript? #\r\nTo write comprehensive grammars in OMeta it is necessary to distinguish between the two languages we are working with. Firstly the OMeta language and secondly the underlying host-language: JavaScript. Outside of a grammar definition only host-language code is valid. For example we are not able to write OMeta rules outside of a grammar.\r\n\r\n    // here only JavaScript can be written\r\n    ometa Grammar {\r\n      // only OMeta is allowed right here\r\n      rule   :a :b = { ... } otherRule !( ... )  -> ...,  // semantic action\r\n      otherRule    = rule:c ?( ... ),                     // semantic predicate\r\n      start        = rule(..., ...) \"rule\" apply(...)     // parametrized rule\r\n    }\r\n    // again: just JavaScript is allowed\r\n\r\n\r\nThe other way around, OMeta is our primary language inside of a grammar definition as it is illustrated the above piece of code. Here we can see that host-language code is valid outside of a grammar ( `... ometa Grammar {} ...` ), inside of semantic predicates ( `?(...)` ), inside of semantic actions ( `{...}`, `!(...)` and `-> ...` ) and inside the call of parametrized rules ( `rule(...)` ). At every occurrence of an ellipsis we might implement a JavaScript expression. As an exception to that rule, in the first case also all JavaScript statements are also allowed.\r\n\r\nHowever, there are some ambiguous notations regarding strings. For example, as we have seen, the notation `\"attention\"` in OMeta-language context is **not a string**. It is equivalent to calling the parametrized function `token` and passing the JavaScript string value `attention` as first argument. In contrast, appearing in host-language context `\"attention\"` represents a string. In order to prevent this confusing usage of double quoted string, the word literal (e.g. `#singleWord`) has been introduced to host-language context. The following table provides an overview of string literals and their semantics depending on the context of use.\r\n\r\n<figure>\r\n  <table>\r\n  <tr>\r\n  <th>\r\n  <th><code>#</code>\r\n  <th><code>\" \"</code>\r\n  <th><code>' '</code>\r\n  <th><code>&#96;&#96; ''</code>\r\n  </tr>\r\n  \r\n  <tr>\r\n  <th>OMeta\r\n  <td>single word string\r\n  <td><code>token(...)</code>\r\n  <td>string-object\r\n  <td>char-sequence\r\n  </tr>\r\n  \r\n  <tr>\r\n  <th>JavaScript\r\n  <td>single word string\r\n  <td>string\r\n  <td>string\r\n  <td>-\r\n  </tr>\r\n\r\n  </table>\r\n  <figcaption>Semantics of string-literals depending on the context</figcaption>\r\n</figure>\r\n\r\n    [tab:Semantics-of-string-literals]\r\n\r\nAll host-language sections inside of a grammar are compiled into individual functions which are called in the context of the grammar-object. Due to this fact, the binding of `this` in these sections is always the grammar-object itself.\r\n\r\n### Grammar Inheritance #\r\nOne of the most important features in OMeta is the reuse and composition of grammars. Grammars can make use of other grammars in two ways. Firstly, a grammar can inherit from another. This is expressed by using the inheritance operator `<:` followed by the grammar to inherit from. If no parent is given, the grammar implicitly inherits from the OMeta base grammar which is stored in the grammar-object `OMeta`. Thus writing `grammar Numbers {}` and `grammar Numbers <: OMeta {}` is equivalent. Of course the parent grammar needs to be compiled first before it can be extended.\r\n\r\nFor example let's extend the number grammar to additionally allow hexadecimal numbers to be matched. This may be achieved by writing a grammar similar to the following one:\r\n\r\n    ometa HexNumbers <: Numbers {\r\n      range :from :to = char:x ?(from <= x && x <= to)             -> x,\r\n      hexDigit        = digit | range('a', 'f') | range('A', 'F'),    \r\n      hex             = ``0x'' <hexDigit+>:ds                      -> parseInt(ds, 16),\r\n      number          = hex | ^number\r\n    }\r\n\r\nThe function `range` is introduced to check for character ranges. The implementation is identical to the one in appendix [chap:OMeta-methods]. It is realized as a parametrized rule expecting two parameters - the lower as well as the upper boundary. Rule `hex` indirectly uses this function to match an arbitrary number of hex digits and returns the decimal value Tthe second argument of the JavaScript function call `parseInt(ds, 16)` is the radix parameter, specifying that the hexadecimal system should be used for parsing). The last rule `number` matches either the rule `hex` or `^number`. The latter is a **super-call** to the parent-grammar applying rule `number`. In general, if a rule isn't defined in the grammar, the lookup automatically continues recursively with the parent-grammar. Given the situation that a rule with the exact same name is defined in the child grammar, just like `number`, this rule is preferred and shadows the implementation of it's parent. This behavior is similar to the one found in classical object orientation. Nevertheless, it is still possible to access the parent-rule by using the super-call operator. The following figure illustrates how OMeta/JS uses the prototypal chain to realize the inheritance of the different grammars.\r\n\r\n<img src=\"images/grammar-inheritance.png\" alt=\"Grammar HexNumbers' prototypal link points to grammar object Numbers, which in turn inherits from the OMeta base grammar.\" />\r\n\r\nAnother example for using this inheritance-mechanism is to create debugging rules:\r\n\r\n    log :rule = ^pos:p <apply(rule)>:t !console.log(\"pos \"+p+\":\", t) -> t,\r\n    next      = ^pos:p &anything:t     !console.log(\"pos \"+p+\":\", t)\r\n\r\nThe first rule `log` is a higher order rule expecting the rule name to apply. It can be used to log the position and input consumed by a special rule. The second rule `next` is a little easier to understand. A positive lookahead is used to log the position and the upcoming element of the input-stream without consuming it.\r\n\r\nSince at the end of the inheritance-chain every grammar implicitly extends OMeta, it is important to know which rules are provided by this special grammar-object. For this purpose a pseudo implementation of all rules the base object offers can be found in appendix [chap:OMeta-methods].\r\n\r\n### Foreign Rule Invocation #\r\nBuilding on top of existing grammars, the mechanism of inheritance is a big advance to the classical way of combining two grammars: Copying both grammars into one file and hope there are no name-clashes. But single inheritance fails when we want to include two or more grammars into a new one. This is when it comes to **foreign rules**.\r\n\r\nGiven the example we want to implement a syntax highlighter that automatically detects SQL strings within another language (for instance JavaScript). Equipped with the two grammars JavaScript and SQL this task can be accomplished pretty easy:\r\n\r\n    ometa Highlighter <: JavaScript {\r\n      string = '\"' SQL.statement:c '\"' -> { type: \"SQLString\", content: c }\r\n             | ^string\r\n    }\r\n\r\nIn this example we are extending the rule `string` to also match SQL strings. If the contents of the string cannot be recognized by the foreign rule `SQL.statement`, the rule falls back to the parent implementation of grammar `JavaScript`. This example illustrates how rules of other grammar objects can just be applied as if they where part of the current grammar. Nevertheless, in contrast to grammar inheritance, applying foreign rules results in a change of contexts. The input stream is just borrowed by the foreign rule and handed back when the matching has been finished. Returning the flow of control is performed anyway, independent of success or error.\r\n\r\nThis procedure can be compared to switch the track for matching and continue on this track as far as we can. After the matching on that track is finished we change the lane again and return to the original grammar. Of course, just like every own rule, the track can always be a dead end.\r\n\r\nThe following figure illustrates the dependencies of the different grammars involved in the previous example.\r\n\r\n<img src=\"images/foreign-rule.png\" alt=\"Highlighter inherits from JavaScript, but invokes the statement-rule of grammar SQL in order to parse special SQL strings.\" />\r\n\r\nAgain, it is an important requirement that all grammar objects have to be loaded in the same environment before they may be used for inheritance or foreign rule invocation.\r\n\r\n\r\nUsing OMeta/JS\r\n--------------\r\nIn the previous section we have learned how to write sophisticated OMeta/JS grammars. In order to be able to use the grammars in combination with the reference implementation we have to do some preparations. The first step is to load all files required to compile the grammars. A list of those files, together with a short description, can be found in appendix [sec:ometa-js-files].\r\n\r\nDue to the large amount of files it appears reasonable to concatenate them to one file, which we may call `ometajs.js` in the remainder of this section. After all, in order to use OMeta/JS the most important three objects implemented in those files are:\r\n\r\n<dl>\r\n  <dt>OMeta</dt>\r\n  <dd>The base grammar object every grammar inherits from.</dd>\r\n  \r\n  <dt>BSOMetaJSParser</dt>\r\n  <dd>This grammar object can be used to parse OMeta/JS grammars, starting with the rule topLevel.<dd>\r\n  \r\n  <dt>BSOMetaJSTranslator</dt>\r\n  <dd>This grammar object can be used to compile the tree, produced by `BSOMetaJSParser`, to JavaScript code. The starting rule for this grammar is `trans`.</dd>\r\n</dl>\r\n\r\nSince OMeta/JS is implemented in JavaScript we may use it inside of a browser environment. In the following, we will set up OMeta in a few steps. For this purpose, we create a html file called `ometa.html` with the following contents:\r\n\r\n    <!DOCTYPE html>\r\n    <html>\r\n      <head>\r\n        <title>OMeta/JS</title>\r\n        <script src=\"ometajs.js\"></script>\r\n        <script language=\"OMetaJS\" id=\"grammar\"> ... </script>\r\n        <script>\r\n          ...\r\n        </script>\r\n      </head>\r\n      <body></body>\r\n    </html>\r\n\r\nThe necessary files to compile and execute OMeta/JS grammars are included in the first script-tag. Inside of the second script-tag with attribute `language` set to `OMetaJS` (Which by the way only is for illustrative purpose) we may now add any OMeta/JS grammar like the `Numbers` grammar, as seen above. The setup of the compilation process, as described in the following, takes place within the third script-tag. First of all we need to retrieve the textual `source` of our grammar definition. This can be easily achieved by requesting the script-tag and reading property `innerHTML`.\r\n\r\n    var source = document.getElementById(\"grammar\").innerHTML;\r\n\r\nThe next step is to parse the source, using `BSOmetaJSParser` which is already loaded into the global namespace by including `ometajs.js`. Like every OMeta object the parser provides the two methods `match` and `matchAll`. At this point only the latter one is of significance.\r\n\r\n    matchAll(input, rule, args?, failure?)\r\n\r\nThe function requires at least two arguments. The first argument, representing the input which is about to be matched by the grammar, has to be a streamable object. This only applies to strings and arrays by default. The second argument `rule` specifies the starting point of the matching process. The remaining arguments are optional. If the starting rule is a parametrized rule, the required arguments can be prepended to the input stream by providing an array as third argument `args`. Finally an optional callback function `failure` can be registered to handle errors.\r\n\r\n    var tree = BSOMetaJSParser.matchAll(source, 'topLevel');\r\n\r\nThe result of the matching process is an OMeta/JS language parse-tree, representing our grammar definition. In order to receive valid JavaScript code we need to translate this tree using the `BSOMetaJSTranslator` object and the method `match`. The required arguments of `match` are exactly the same like the ones of `matchAll`, with the exception that any JavaScript object may be provided as `input` (For instance the OMeta grammar `ometa Four { n = 4 }` will successfully match the number four by applying `Four.match(4, 'n')`). In this case we are matching the syntax tree resulting from the previous step.\r\n\r\n    var grammar = BSOMetaJSTranslator.match(tree, 'trans');\r\n\r\nAfter applying the above line, the variable grammar contains a textual representation of JavaScript code. To bring it to life and in order to actually use our grammar object we have to evaluate the JavaScript-string.\r\n\r\n    eval(grammar);\r\n\r\nThis introduces a new variable in the global scope named identical to the compiled grammar. In this case the variable `Numbers` will contain the desired grammar object.\r\n\r\n### Stateful Pattern Matching #\r\nBy adding semantic actions OMeta allows not only to manipulate the results of expressions (for instance in order to create the syntax tree), but also to trigger side effects during the process of matching. This can be really useful, for instance if we want to gather information such as the occurrence of strings in order to collect them in a string table. An example of how this task can be achieved is illustrated in the next code sample:\r\n\r\n    ometa SomeParser {\r\n      ...\r\n      string = '\"' <(~'\"' char)+>:cs '\"' !this.collect(cs):i -> { type: \"String\", id: i }\r\n      ...\r\n    }\r\n    Parser.initialize = function() { this.strings = []; }\r\n    Parser.collect = function(string) {\r\n      var i = this.strings.indexOf(string);\r\n      if(i === -1)\r\n        return this.strings.push(string) - 1;\r\n      else\r\n        return i;\r\n    }\r\n\r\nIn this example `SomeParser` makes use of semantic actions like `!this.collect` to push all found strings in a shared string table. Each string is only stored once - duplicates are filtered. Each string is finally replaced with an AST node containing the id (the position of the string inside of the collection), not the value itself. The callback function `initialize` is registered in order to prepare the parser instance before the matching can start.\r\n\r\n\r\nSummary\r\n-------\r\nOMeta/JS rendered itself to be an elegant solution for the different steps of compilation. It allows to match not only streams of characters, but also arbitrary host objects. To provide this functionality, the OMeta language shows some differences compared to common parsing expression grammars. Additionally, it equips the developer with features like left-recursion, semantic predicates, semantic actions, grammar inheritance and foreign rule invocation. We have seen how parametrized rules can be combined with the rule `apply` to create higher order rules. Nevertheless, there are some pitfalls like the difference between host-language and OMeta context. Moreover, the subtle distinction between the various string-literals is not quite easy and requires some attention.\r\n\r\nDue to the fact that setting up OMeta requires the inclusion of many files, we have concatenated them all into one single file. This allows to work with OMeta grammars more easily.","tagline":"OMeta for JavaScript","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}